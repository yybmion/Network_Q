# 프로세스끼리 협력하는 방법(IPC)

1. **IPC의 정의**
    - 프로세스들이 **서로 데이터를 주고받는 메커니즘**이다.
    - **독립적인 프로세스**들 간의 `협력`과 `동기화`를 가능하게 한다.

2. **IPC의 필요성**
    - **데이터 공유**: 프로세스 간 **정보 교환**
    - **계산 속도 향상**: 작업을 분할하여 병렬 처리
    - **모듈화**: 시스템 기능을 **별도 프로세스로 분리**
    - **편의성**: 여러 사용자가 동시에 같은 데이터에 접근

3. **주요 IPC 방식**
    - **파이프 (Pipe)**
    - **명명된 파이프 (Named Pipe)**
    - **메시지 큐 (Message Queue)**
    - **공유 메모리 (Shared Memory)**
    - **메모리 맵 (Memory Map)**
    - **소켓 (Socket)**

4. **각 IPC 방식의 특징**
    - **파이프**: 단방향 통신, 부모-자식 프로세스 간 사용
    - **명명된 파이프**: 양방향 통신, 관련 없는 프로세스 간 사용 가능
    - **메시지 큐**: 비동기 통신, 구조화된 데이터 전송
    - **공유 메모리**: 가장 빠른 IPC, 동기화 주의 필요
    - **메모리 맵**: 파일을 메모리에 맵핑하여 공유
    - **소켓**: 네트워크 통신에 사용, 원격 프로세스 간 통신 가능

5. **IPC 선택 시 고려사항**
    - **통신 속도**: 공유 메모리가 가장 빠름
    - **편의성**: 메시지 큐나 소켓이 사용하기 쉬움
    - **통신 방향**: 단방향 또는 양방향
    - **동기화 요구사항**: 공유 메모리는 별도의 동기화 메커니즘 필요
    - **프로세스 관계**: 관련 있는 프로세스인지, 독립적인 프로세스인지

6. **IPC의 장단점**
   **장점**:
    - **데이터 공유**와 프로세스 협력 가능
    - **모듈화**와 유연한 시스템 설계 가능


   **단점**:
    - **복잡성 증가**: 동기화와 데이터 일관성 관리 필요
    - **잠재적 성능 저하**: 과도한 IPC 사용 시 오버헤드 발생

7. **IPC와 관련된 문제**
    - **교착 상태 (Deadlock)**: 두 프로세스가 서로의 자원을 기다리며 블록된 상태
    - **경쟁 상태 (Race Condition)**: 공유 자원에 대한 동시 접근으로 인한 데이터 불일치

📌 **요약**: IPC는 프로세스 간 데이터 공유와 협력을 위한 필수적인 메커니즘이다. 파이프, 메시지 큐, 공유 메모리 등 다양한 방식이 있으며, 각각의 특성에 따라 적절히 선택해야 한다. IPC는 시스템의 모듈화와 성능 향상에 기여하지만, 동기화와 데이터 일관성 관리에 주의가 필요하다. 효과적인 IPC 사용은 복잡한 시스템 설계와 구현에 핵심적인 역할을 한다.

___
### 보충정리

1. 파이프 (Unnamed Pipe)

`파이프`는 가장 오래되고 간단한 IPC 메커니즘 중 하나입니다. 주로 **부모-자식 프로세스 간의 통신**에 사용됩니다.

특징:
- 단방향 통신: 한쪽은 쓰기만, 다른 쪽은 읽기만 가능
- 부모-자식 프로세스 관계에서만 사용 가능
- 파일 시스템에 이름이 없음
- 프로세스가 종료되면 파이프도 자동으로 제거됨


사용 예:
```c
int pipefd[2];
pipe(pipefd);
if (fork() == 0) {
    // 자식 프로세스
    close(pipefd[1]);  // 쓰기 종단 닫기
    read(pipefd[0], buf, sizeof(buf));
} else {
    // 부모 프로세스
    close(pipefd[0]);  // 읽기 종단 닫기
    write(pipefd[1], "Hello", 5);
}
```

2. 명명된 파이프 (Named Pipe or FIFO)

`명명된 파이프`는 일반 **파이프의 제한을 극복하기 위해** 만들어졌습니다.

특징:
- 양방향 통신 가능 (두 개의 명명된 파이프 사용)
- **서로 관련 없는 프로세스들 간에도 통신 가능**
- 파일 시스템에 이름이 있어 여러 프로세스가 접근 가능
- 프로세스가 종료되어도 파이프가 자동으로 제거되지 않음



사용 예:
```c
// 프로세스 A
mkfifo("/tmp/myfifo", 0666);
int fd = open("/tmp/myfifo", O_WRONLY);
write(fd, "Hello", 5);
close(fd);

// 프로세스 B
int fd = open("/tmp/myfifo", O_RDONLY);
read(fd, buf, sizeof(buf));
close(fd);
```

네, 메시지 큐와 공유 메모리에 대해 자세히 설명해 드리겠습니다.

3. 메시지 큐 (Message Queue)

메시지 큐는 프로세스 간에 데이터를 전달하기 위한 큐 형태의 통신 방식입니다.

특징:
- 비동기적 통신 가능
- 여러 프로세스가 동시에 읽고 쓸 수 있음
- 메시지는 고정된 최대 크기를 가짐
- 우선순위 지정 가능
- 시스템 재부팅 시 제거됨 (영구적이지 않음)


사용 예 (POSIX 메시지 큐):
```c
// 송신 프로세스
mqd_t mq = mq_open("/myqueue", O_CREAT | O_WRONLY, 0644, &attr);
mq_send(mq, "Hello", 5, 0);
mq_close(mq);

// 수신 프로세스
mqd_t mq = mq_open("/myqueue", O_RDONLY);
mq_receive(mq, buffer, SIZE, NULL);
mq_close(mq);
```

4. 공유 메모리 (Shared Memory)

공유 메모리는 여러 프로세스가 동일한 메모리 영역을 공유하여 통신하는 방식입니다.

특징:
- 가장 빠른 IPC 방법
- 직접 메모리에 접근하므로 커널의 개입이 최소화됨
- 동기화 메커니즘이 별도로 필요 (예: 세마포어)
- 큰 데이터를 효율적으로 공유 가능
- 시스템 재부팅 시 제거됨 (영구적이지 않음)


사용 예 (POSIX 공유 메모리):
```c
// 공유 메모리 생성 및 매핑
int fd = shm_open("/myshm", O_CREAT | O_RDWR, 0644);
ftruncate(fd, 4096);
void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

// 프로세스 A: 쓰기
strcpy(ptr, "Hello");

// 프로세스 B: 읽기
printf("%s\n", (char *)ptr);

// 정리
munmap(ptr, 4096);
close(fd);
shm_unlink("/myshm");
```

메시지 큐와 공유 메모리 비교:

1. 속도: 공유 메모리가 일반적으로 더 빠름
2. 데이터 크기: 메시지 큐는 제한된 크기, 공유 메모리는 큰 데이터 처리 가능
3. 동기화: 메시지 큐는 내장된 동기화 기능, 공유 메모리는 별도 동기화 필요
4. 사용 복잡성: 메시지 큐가 일반적으로 사용하기 더 쉬움
5. 데이터 구조: 메시지 큐는 구조화된 데이터, 공유 메모리는 raw 데이터

네, 메모리 맵과 소켓에 대해 자세히 설명해 드리겠습니다.

5. 메모리 맵 (Memory-Mapped File)

메모리 맵은 파일이나 디바이스의 내용을 프로세스의 주소 공간에 직접 매핑하는 기술입니다. 이를 통해 파일 I/O 대신 메모리 접근으로 데이터를 처리할 수 있습니다.

특징:
- 파일을 메모리에 매핑하여 빠른 접근 가능
- 여러 프로세스가 동일한 파일을 공유 가능
- 큰 파일도 효율적으로 처리 가능
- 페이지 폴트를 통한 요구 페이징 지원
- 메모리와 파일 간 동기화 필요


사용 예 (POSIX mmap):
```c
int fd = open("file.txt", O_RDWR);
char *data = mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

// 데이터 읽기/쓰기
printf("%s\n", data);
strcpy(data, "New content");

munmap(data, file_size);
close(fd);
```

6. 소켓 (Socket)

소켓은 네트워크를 통해 데이터를 주고받을 수 있는 통신 엔드포인트입니다. 로컬 프로세스 간 통신뿐만 아니라 원격 프로세스 간 통신에도 사용됩니다.

특징:
- 로컬 및 원격 통신 모두 지원
- 다양한 프로토콜 지원 (TCP, UDP 등)
- 양방향 통신 가능
- 네트워크 프로그래밍의 기본 단위
- 동기 및 비동기 통신 모두 지원


사용 예 (TCP 소켓):
```c
// 서버
int server_fd = socket(AF_INET, SOCK_STREAM, 0);
bind(server_fd, (struct sockaddr *)&address, sizeof(address));
listen(server_fd, 3);
int new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
recv(new_socket, buffer, 1024, 0);
send(new_socket, hello, strlen(hello), 0);

// 클라이언트
int sock = socket(AF_INET, SOCK_STREAM, 0);
connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
send(sock, hello, strlen(hello), 0);
recv(sock, buffer, 1024, 0);
```

메모리 맵과 소켓 비교:

1. 용도: 메모리 맵은 주로 파일 접근 최적화, 소켓은 네트워크 통신에 사용
2. 범위: 메모리 맵은 주로 로컬 시스템 내, 소켓은 로컬 및 원격 통신 가능
3. 데이터 접근: 메모리 맵은 직접 메모리 접근, 소켓은 send/recv 함수 사용
4. 동기화: 메모리 맵은 별도 동기화 필요, 소켓은 통신 프로토콜에 의해 관리
5. 성능: 메모리 맵은 로컬에서 매우 빠름, 소켓은 네트워크 지연 발생 가능

